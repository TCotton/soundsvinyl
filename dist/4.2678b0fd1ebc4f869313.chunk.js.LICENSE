/* 0 */

/* 1 */

/* 2 */

/* 3 */

/* 4 */

/* 5 */

/* 6 */

/* 7 */

/* 8 */

/* 9 */

/* 10 */

/***/

/* 11 */

// By explicitly using `prop-types` you are opting into new production behavior.

// http://fb.me/prop-types-in-prod

/* 12 */

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js

// EXTERNAL MODULE: ./node_modules/react/index.js

/*#__PURE__*/

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js

// CONCATENATED MODULE: ./node_modules/resolve-pathname/esm/resolve-pathname.js

// About 1.5x faster than the two-arg version of Array#splice()

// This implementation is based heavily on node's url.parse

/* harmony default export */

// to is absolute

// to is relative, drop the filename

// CONCATENATED MODULE: ./node_modules/value-equal/esm/value-equal.js

// Test for strict equality first.

// Otherwise, if either of them == null they are not equal.

// CONCATENATED MODULE: ./node_modules/tiny-invariant/dist/tiny-invariant.esm.js

// CONCATENATED MODULE: ./node_modules/history/esm/history.js

// Two-arg form: push(path, state)

// One-arg form: push(location)

// Resolve incomplete/relative pathname relative to current location.

// When there is no prior location and pathname is empty, set it to /

// TODO: If another transition starts while we're still confirming

// the previous one, we may end up in a weird state. Figure out the

// best way to handle this.

// Return false from a transition hook to cancel the transition.

// eslint-disable-line no-alert

/**
 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
 *
 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
 * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586
 */

// IE 11 sometimes throws when accessing window.history.state

// See https://github.com/ReactTraining/history/pull/289

/**
 * Creates a history object that uses the HTML5 history API including
 * pushState, replaceState, and the popstate event.
 */

// Ignore extraneous popstate events in WebKit.

/**
 * Returns true if a given popstate event is an extraneous WebKit event.
 * Accounts for the fact that Chrome on iOS fires real popstate events
 * containing undefined state when pressing the back button.
 */

// TODO: We could probably make this more reliable by

// keeping a list of keys we've seen in sessionStorage.

// Instead, we just default to 0 for keys we don't know.

// Public interface

// We can't use window.location.hash here because it's not

// consistent across browsers - Firefox will pre-decode it!

// Ensure we always have a properly-encoded hash.

// A hashchange doesn't always == location change.

// Ignore this change; we already setState in push/replace.

// keeping a list of paths we've seen in sessionStorage.

// Instead, we just default to 0 for paths we don't know.

// Ensure the hash is encoded properly before doing anything else.

// We cannot tell if a hashchange was caused by a PUSH, so we'd

// rather setState here and ignore the hashchange. The caveat here

// is that other hash histories in the page will consider it a POP.

// We cannot tell if a hashchange was caused by a REPLACE, so we'd

/**
 * Creates a history object that stores locations in memory.
 */

// EXTERNAL MODULE: ./node_modules/mini-create-react-context/node_modules/@babel/runtime/helpers/inheritsLoose.js

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js

// EXTERNAL MODULE: ./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js

// This is a bit of a hack. We have to start listening for location

// changes here in the constructor in case there are any <Redirect>s

// on the initial render. If there are, they will replace/push when

// they mount and since cDM fires in children before parents, we may

// get a new location before the <Router> is mounted.

/**
 * The public API for a <Router> that stores location in memory.
 */

// Mimic the behavior of DOM histories by

// causing a render after a cancelled POP.

/**
 * The public API for prompting the user before navigating away from a screen.
 */

/**
 * Public API for generating a URL pathname from a path and parameters.
 */

/**
 * The public API for navigating programmatically with a component.
 */

// When rendering in a static context,

// set the new location immediately.

/**
 * Public API for matching a URL pathname to a path.
 */

// the path used to match

// the matched portion of the URL

// whether or not we matched exactly

/**
 * The public API for matching a single path and rendering.
 */

// Preact uses an empty array as children by

// default, so use null if that's the case.

/**
 * The public top-level API for a "static" <Router>, so-called because it
 * can't actually change the current location. Instead, it just records
 * location changes in a context object. Useful mainly in testing and
 * server-rendering scenarios.
 */

/**
 * The public API for rendering the first <Route> that matches.
 */

// We use React.Children.forEach instead of React.Children.toArray().find()

// here because toArray adds keys to all child elements and we do not want

// to trigger an unmount/remount for two <Route>s that render the same

// component at different URLs.

/**
 * A public higher-order component to access the imperative API
 */

//# sourceMappingURL=react-router.js.map

// CONCATENATED MODULE: ./node_modules/react-router-dom/esm/react-router-dom.js

/* harmony export (binding) */

/* concated harmony reexport MemoryRouter */

/* concated harmony reexport Prompt */

/* concated harmony reexport Redirect */

/* concated harmony reexport Route */

/* concated harmony reexport Router */

/* concated harmony reexport StaticRouter */

/* concated harmony reexport Switch */

/* concated harmony reexport __RouterContext */

/* concated harmony reexport generatePath */

/* concated harmony reexport matchPath */

/* concated harmony reexport useHistory */

/* concated harmony reexport useLocation */

/* concated harmony reexport useParams */

/* concated harmony reexport useRouteMatch */

/* concated harmony reexport withRouter */

/**
 * The public API for a <Router> that uses HTML5 history.
 */

/**
 * The public API for a <Router> that uses window.location.hash.
 */

// onClick prevented default

// ignore everything but left clicks

// React 15 compat

/**
 * The public API for rendering a history-aware <a>.
 */

/**
 * A <Link> wrapper that knows if it's "active" or not.
 */

/* 13 */

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */

// Don't bother if no value provided

// Force an array if not already something iterable

/*eslint no-param-reassign:0*/

// Iterate over array values

// Iterate over object keys

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */

/**
 * Function equal to merge with the difference being that no reference
 * to original objects is kept.
 *
 * @see merge
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */

/* 14 */

/* 15 */

/* 16 */

/* 17 */

/* 18 */

/* 19 */

/* 20 */

/* 21 */

/* 22 */

/* 23 */

/* 24 */

/* 25 */

/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

/* eslint-disable no-unused-vars */

// Detect buggy property enumeration order in older V8 versions.

// https://bugs.chromium.org/p/v8/issues/detail?id=4118

// eslint-disable-line no-new-wrappers

// https://bugs.chromium.org/p/v8/issues/detail?id=3056

// We don't expect any of the above to throw, but better to be safe.

/* 26 */

/* 27 */

/* 28 */

/* 29 */

/* 30 */

/* 31 */

/* 32 */

/* 33 */

/* 34 */

/* 35 */

/* 36 */

// DCE check should happen before ReactDOM bundle executes so that

// DevTools can report bad minification during injection.

/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */

// Verify that the code above has been dead code eliminated (DCE'd).

// DevTools shouldn't crash React, no matter what.

// We should still report in case we break this code.

/* 37 */

/* 38 */

/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */

// don't hoist over string (html) components

// Avoid failures from read-only properties

/* 39 */

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

// we don't care about invariant's own frame

/* 40 */

// shim for using process in browser

// cached from whatever global is present so that test runners that stub it

// don't break things.  But we need to wrap it in a try catch in case it is

// wrapped in strict mode code which doesn't define any globals.  It's inside a

// function because try/catches deoptimize in certain engines.

//normal enviroments in sane situations

// if setTimeout wasn't available but was latter defined

// when when somebody has screwed with setTimeout but no I.E. maddness

// When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally

// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error

// if clearTimeout wasn't available but was latter defined

// When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally

// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.

// Some versions of I.E. have different rules for clearTimeout vs setTimeout

// v8 likes predictible objects

// empty string to avoid regexp issues

/* 41 */

/* 42 */

/* 43 */

/* 44 */

/* 45 */

/* 46 */

/* 47 */

/* 48 */

/* 49 */

/* 50 */

/* 51 */

/* 52 */

/* 53 */

/* 54 */

/* 55 */

/* 56 */

/* 57 */

/* 58 */

/* 59 */

/* 60 */

/* 61 */

/* 62 */

/* 63 */

/* 64 */

/* 65 */

/* 66 */

/* 67 */

/* 68 */

/* 69 */

/* 70 */

/* 71 */

/* 72 */

/* 73 */

/* 74 */

/* 75 */

/* 76 */

/* 77 */

/* 78 */

/* 79 */

/* 80 */

/* 81 */

/* 82 */

/* 83 */

/* 84 */

/* 85 */

/* 86 */

/* 87 */

/* 88 */

/* 89 */

/* 90 */

// CONCATENATED MODULE: ./node_modules/react-redux/es/utils/batch.js

// Default to a dummy "batch" implementation that just runs the callback

// Allow injecting another batching function later

// CONCATENATED MODULE: ./node_modules/react-redux/es/components/Provider.js

// CONCATENATED MODULE: ./node_modules/react-redux/node_modules/@babel/runtime/helpers/esm/extends.js

// CONCATENATED MODULE: ./node_modules/react-redux/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js

// React currently throws a warning when using useLayoutEffect on the server.

// To get around it, we can conditionally useEffect on the server (no-op) and

// useLayoutEffect in the browser. We need useLayoutEffect because we want

// `connect` to perform sync updates to a ref to save the latest props after

// a render is actually committed to the DOM.

/*
  selectorFactory is a func that is responsible for returning the selector function used to
  compute new props from state, props, and dispatch. For example:
     export default connectAdvanced((dispatch, options) => (state, props) => ({
      thing: state.things[props.thingId],
      saveThing: fields => dispatch(actionCreators.saveThing(props.thingId, fields)),
    }))(YourComponent)
   Access to dispatch is provided to the factory so selectorFactories can bind actionCreators
  outside of their selector as an optimization. Options passed to connectAdvanced are passed to
  the selectorFactory, along with displayName and WrappedComponent, as the second argument.
   Note that selectorFactory is responsible for all caching/memoization of inbound and outbound
  props. Do not use connectAdvanced directly without memoizing results between calls to your
  selector, otherwise the Connect component will re-render on every state or props change.
*/

// options object:

// If we aren't running in "pure" mode, we don't want to memoize values.

// To avoid conditionally calling hooks, we fall back to a tiny wrapper

// that just executes the given callback immediately.

// Distinguish between actual "data" props that were passed to the wrapper component,

// and values needed to control behavior (forwarded refs, alternate context instances).

// To maintain the wrapperProps object reference, memoize this destructuring.

// Users may optionally pass in a custom context instance to use instead of our ReactReduxContext.

// Memoize the check that determines which context instance we should use.

// The child props selector needs the store reference as an input.

// Re-create this selector whenever the store changes.

// This Subscription's source should match where store came from: props vs. context. A component

// connected to the store via props shouldn't use subscription from context, or vice versa.

// `notifyNestedSubs` is duplicated to handle the case where the component is unmounted in

// the middle of the notification loop, where `subscription` will then be null. This can

// probably be avoided if Subscription's listeners logic is changed to not call listeners

// that have been unsubscribed in the  middle of the notification loop.

// Otherwise, put this component's subscription instance into context, so that

// connected descendants won't update until after this component is done

// Propagate any mapState/mapDispatch errors upwards

// Set up refs to coordinate values between the subscription effect and the render logic

// Tricky logic here:

// - This render may have been triggered by a Redux store update that produced new child props

// - However, we may have gotten new wrapper props after that

// If we have new child props, and the same wrapper props, we know we should use the new child props as-is.

// But, if we have new wrapper props, those might change the child props, so we have to recalculate things.

// So, we'll use the child props from store update only if the wrapper props are the same as last time.

// TODO We're reading the store directly in render() here. Bad idea?

// This will likely cause Bad Things (TM) to happen in Concurrent Mode.

// Note that we do this because on renders _not_ caused by store updates, we need the latest store state

// to determine what the child props should be.

// We need this to execute synchronously every time we re-render. However, React warns

// about useLayoutEffect in SSR, so we try to detect environment and fall back to

// just useEffect instead to avoid the warning, since neither will run anyway.

// We want to capture the wrapper props and child props we used for later comparisons

// If the render was from a store update, clear out that reference and cascade the subscriber update

// Our re-subscribe logic only runs when the store/subscription setup changes

// If we're not subscribed to the store, nothing to do here

// Capture values for checking if and when this component unmounts

// Actually run the selector with the most recent store state and wrapper props

// to determine what the child props should be

// If the child props haven't changed, nothing to do here - cascade the subscription update

// Save references to the new child props.  Note that we track the "child props from store update"

// as a ref instead of a useState/useReducer because we need a way to determine if that value has

// been processed.  If this went into useState/useReducer, we couldn't clear out the value without

// forcing another re-render, which we don't want.

// If the child props _did_ change (or we caught an error), this wrapper component needs to re-render

// Actually subscribe to the nearest connected ancestor (or store)

// Pull data from the store after first render in case the store has

// changed since we began.

// It's possible that we caught an error due to a bad mapState function, but the

// parent re-rendered without this component and we're about to unmount.

// This shouldn't happen as long as we do top-down subscriptions correctly, but

// if we ever do those wrong, this throw will surface the error in our tests.

// In that case, throw the error from here so it doesn't get lost.

// Now that all that's done, we can finally try to actually render the child component.

// We memoize the elements for the rendered child component as an optimization.

// If React sees the exact same element reference as last time, it bails out of re-rendering

// that child, same as if it was wrapped in React.memo() or returned false from shouldComponentUpdate.

// If we're in "pure" mode, ensure our wrapper component only re-renders when incoming props have changed.

// CONCATENATED MODULE: ./node_modules/react-redux/es/utils/shallowEqual.js

// EXTERNAL MODULE: ./node_modules/redux/es/redux.js

// CONCATENATED MODULE: ./node_modules/react-redux/es/utils/isPlainObject.js

/**
 * @param {any} obj The object to inspect.
 * @returns {boolean} True if the argument appears to be a plain object.
 */

// CONCATENATED MODULE: ./node_modules/react-redux/es/connect/wrapMapToProps.js

// dependsOnOwnProps is used by createMapToPropsProxy to determine whether to pass props as args

// to the mapToProps function being wrapped. It is also used by makePurePropsSelector to determine

// whether mapToProps needs to be invoked when props have changed.

//

// A length of one signals that mapToProps does not depend on props from the parent component.

// A length of zero is assumed to mean mapToProps is getting args via arguments or ...args and

// therefore not reporting its length accurately..

// Used by whenMapStateToPropsIsFunction and whenMapDispatchToPropsIsFunction,

// this function wraps mapToProps in a proxy function which does several things:

//  * Detects whether the mapToProps function being called depends on props, which

//    is used by selectorFactory to decide if it should reinvoke on props changes.

//  * On first call, handles mapToProps if returns another function, and treats that

//    new function as the true mapToProps for subsequent calls.

//  * On first call, verifies the first result is a plain object, in order to warn

//    the developer that their mapToProps function is not returning a valid result.

// allow detectFactoryAndVerify to get ownProps

// CONCATENATED MODULE: ./node_modules/react-redux/es/connect/mapDispatchToProps.js

// CONCATENATED MODULE: ./node_modules/react-redux/es/connect/mapStateToProps.js

// CONCATENATED MODULE: ./node_modules/react-redux/es/connect/mergeProps.js

// CONCATENATED MODULE: ./node_modules/react-redux/es/connect/verifySubselectors.js

// CONCATENATED MODULE: ./node_modules/react-redux/es/connect/selectorFactory.js

// TODO: Add more comments

// If pure is true, the selector returned by selectorFactory will memoize its results,

// allowing connectAdvanced's shouldComponentUpdate to return false if final

// props have not changed. If false, the selector will always return a new

// object and shouldComponentUpdate will always return true.

// CONCATENATED MODULE: ./node_modules/react-redux/es/connect/connect.js

/*
  connect is a facade over connectAdvanced. It turns its args into a compatible
  selectorFactory, which has the signature:

    (dispatch, options) => (nextState, nextOwnProps) => nextFinalProps
  
  connect passes its args to connectAdvanced as options, which will in turn pass them to
  selectorFactory each time a Connect component instance is instantiated or hot reloaded.

  selectorFactory returns a final props selector from its mapStateToProps,
  mapStateToPropsFactories, mapDispatchToProps, mapDispatchToPropsFactories, mergeProps,
  mergePropsFactories, and pure args.

  The resulting final props selector is called by the Connect component instance whenever
  it receives new props or store state.
 */

// createConnect with default args builds the 'official' connect behavior. Calling it with

// different options opens up some testing and extensibility scenarios

// used in error messages

// used to compute Connect's displayName from the wrapped component's displayName.

// if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes

// passed through to selectorFactory

// CONCATENATED MODULE: ./node_modules/react-redux/es/hooks/useReduxContext.js

/**
 * A hook to access the value of the `ReactReduxContext`. This is a low-level
 * hook that you should usually not need to call directly.
 *
 * @returns {any} the value of the `ReactReduxContext`
 *
 * @example
 *
 * import React from 'react'
 * import { useReduxContext } from 'react-redux'
 *
 * export const CounterComponent = ({ value }) => {
 *   const { store } = useReduxContext()
 *   return <div>{store.getState()}</div>
 * }
 */

// CONCATENATED MODULE: ./node_modules/react-redux/es/hooks/useStore.js

/**
 * Hook factory, which creates a `useStore` hook bound to a given context.
 *
 * @param {Function} [context=ReactReduxContext] Context passed to your `<Provider>`.
 * @returns {Function} A `useStore` hook bound to the specified context.
 */

/**
 * A hook to access the redux store.
 *
 * @returns {any} the redux store
 *
 * @example
 *
 * import React from 'react'
 * import { useStore } from 'react-redux'
 *
 * export const ExampleComponent = () => {
 *   const store = useStore()
 *   return <div>{store.getState()}</div>
 * }
 */

// CONCATENATED MODULE: ./node_modules/react-redux/es/hooks/useDispatch.js

/**
 * Hook factory, which creates a `useDispatch` hook bound to a given context.
 *
 * @param {Function} [context=ReactReduxContext] Context passed to your `<Provider>`.
 * @returns {Function} A `useDispatch` hook bound to the specified context.
 */

/**
 * A hook to access the redux `dispatch` function.
 *
 * @returns {any|function} redux store's `dispatch` function
 *
 * @example
 *
 * import React, { useCallback } from 'react'
 * import { useDispatch } from 'react-redux'
 *
 * export const CounterComponent = ({ value }) => {
 *   const dispatch = useDispatch()
 *   const increaseCounter = useCallback(() => dispatch({ type: 'increase-counter' }), [])
 *   return (
 *     <div>
 *       <span>{value}</span>
 *       <button onClick={increaseCounter}>Increase counter</button>
 *     </div>
 *   )
 * }
 */

// CONCATENATED MODULE: ./node_modules/react-redux/es/hooks/useSelector.js

// useLayoutEffect in the browser. We need useLayoutEffect to ensure the store

// subscription callback always has the selector from the latest render commit

// available, otherwise a store update may happen between render and the effect,

// which may cause missed updates; we also must ensure the store subscription

// is created synchronously, otherwise a store update may occur before the

// subscription is created and an inconsistent state may be observed

/**
 * Hook factory, which creates a `useSelector` hook bound to a given context.
 *
 * @param {Function} [context=ReactReduxContext] Context passed to your `<Provider>`.
 * @returns {Function} A `useSelector` hook bound to the specified context.
 */

// we ignore all errors here, since when the component

// is re-rendered, the selectors are called again, and

// will throw again, if neither props nor store state

// changed

/**
 * A hook to access the redux store's state. This hook takes a selector function
 * as an argument. The selector is called with the store state.
 *
 * This hook takes an optional equality comparison function as the second parameter
 * that allows you to customize the way the selected state is compared to determine
 * whether the component needs to be re-rendered.
 *
 * @param {Function} selector the selector function
 * @param {Function=} equalityFn the function that will be used to determine equality
 *
 * @returns {any} the selected state
 *
 * @example
 *
 * import React from 'react'
 * import { useSelector } from 'react-redux'
 *
 * export const CounterComponent = () => {
 *   const counter = useSelector(state => state.counter)
 *   return <div>{counter}</div>
 * }
 */

// EXTERNAL MODULE: ./node_modules/react-dom/index.js

// CONCATENATED MODULE: ./node_modules/react-redux/es/utils/reactBatchedUpdates.js

/* eslint-disable import/no-unresolved */

// CONCATENATED MODULE: ./node_modules/react-redux/es/index.js

/* concated harmony reexport Provider */

/* concated harmony reexport connectAdvanced */

/* concated harmony reexport ReactReduxContext */

/* concated harmony reexport connect */

/* concated harmony reexport batch */

/* concated harmony reexport useDispatch */

/* concated harmony reexport createDispatchHook */

/* concated harmony reexport useSelector */

/* concated harmony reexport createSelectorHook */

/* concated harmony reexport useStore */

/* concated harmony reexport createStoreHook */

/* concated harmony reexport shallowEqual */

/* 91 */

/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

/**
 * Parse a cookie header.
 *
 * Parse the given cookie header string into an object
 * The object has the various cookies as keys(names) => values
 *
 * @param {string} str
 * @param {object} [options]
 * @return {object}
 * @public
 */

// skip things that don't look like key=value

// quoted values

// only assign once

/**
 * Serialize data into a cookie header.
 *
 * Serialize the a name value pair into a cookie string suitable for
 * http headers. An optional options object specified cookie parameters.
 *
 * serialize('foo', 'bar', { httpOnly: true })
 *   => "foo=bar; httpOnly"
 *
 * @param {string} name
 * @param {string} val
 * @param {object} [options]
 * @return {string}
 * @public
 */

/**
 * Try decoding a string using a decoding function.
 *
 * @param {string} str
 * @param {function} decode
 * @private
 */

/**
 * Module variables.
 * @private
 */

/* 92 */

/* harmony import */

/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */

/**
 * Creates a Redux store that holds the state tree.
 * The only way to change the data in the store is to call `dispatch()` on it.
 *
 * There should only be a single store in your app. To specify how different
 * parts of the state tree respond to actions, you may combine several reducers
 * into a single reducer function by using `combineReducers`.
 *
 * @param {Function} reducer A function that returns the next state tree, given
 * the current state tree and the action to handle.
 *
 * @param {any} [preloadedState] The initial state. You may optionally specify it
 * to hydrate the state from the server in universal apps, or to restore a
 * previously serialized user session.
 * If you use `combineReducers` to produce the root reducer function, this must be
 * an object with the same shape as `combineReducers` keys.
 *
 * @param {Function} [enhancer] The store enhancer. You may optionally specify it
 * to enhance the store with third-party capabilities such as middleware,
 * time travel, persistence, etc. The only store enhancer that ships with Redux
 * is `applyMiddleware()`.
 *
 * @returns {Store} A Redux store that lets you read the state, dispatch actions
 * and subscribe to changes.
 */

/**
   * This makes a shallow copy of currentListeners so we can use
   * nextListeners as a temporary list while dispatching.
   *
   * This prevents any bugs around consumers calling
   * subscribe/unsubscribe in the middle of a dispatch.
   */

/**
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */

/**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */

/**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing “what changed”. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */

/**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */

// When a store is created, an "INIT" action is dispatched so that every

// reducer returns their initial state. This effectively populates

// the initial state tree.

// This action has a similiar effect to ActionTypes.INIT.

// Any reducers that existed in both the new and old rootReducer

// will receive the previous state. This effectively populates

// the new state tree with any relevant data from the old one.

/**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/tc39/proposal-observable
   */

/**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */

/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */

/**
 * Turns an object whose values are different reducer functions, into a single
 * reducer function. It will call every child reducer, and gather their results
 * into a single state object, whose keys correspond to the keys of the passed
 * reducer functions.
 *
 * @param {Object} reducers An object whose values correspond to different
 * reducer functions that need to be combined into one. One handy way to obtain
 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
 * undefined for any action. Instead, they should return their initial state
 * if the state passed to them was undefined, and the current state for any
 * unrecognized action.
 *
 * @returns {Function} A reducer function that invokes every reducer inside the
 * passed object, and builds a state object with the same shape.
 */

// This is used to make sure we don't warn about the same

// keys multiple times.

/**
 * Turns an object whose values are action creators, into an object with the
 * same keys, but with every function wrapped into a `dispatch` call so they
 * may be invoked directly. This is just a convenience method, as you can call
 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
 *
 * For convenience, you can also pass an action creator as the first argument,
 * and get a dispatch wrapped function in return.
 *
 * @param {Function|Object} actionCreators An object whose values are action
 * creator functions. One handy way to obtain it is to use ES6 `import * as`
 * syntax. You may also pass a single function.
 *
 * @param {Function} dispatch The `dispatch` function available on your Redux
 * store.
 *
 * @returns {Function|Object} The object mimicking the original object, but with
 * every action creator wrapped into the `dispatch` call. If you passed a
 * function as `actionCreators`, the return value will also be a single
 * function.
 */

/**
 * Composes single-argument functions from right to left. The rightmost
 * function can take multiple arguments as it provides the signature for
 * the resulting composite function.
 *
 * @param {...Function} funcs The functions to compose.
 * @returns {Function} A function obtained by composing the argument functions
 * from right to left. For example, compose(f, g, h) is identical to doing
 * (...args) => f(g(h(...args))).
 */

/**
 * Creates a store enhancer that applies middleware to the dispatch method
 * of the Redux store. This is handy for a variety of tasks, such as expressing
 * asynchronous actions in a concise manner, or logging every action payload.
 *
 * See `redux-thunk` package as an example of the Redux middleware.
 *
 * Because middleware is potentially asynchronous, this should be the first
 * store enhancer in the composition chain.
 *
 * Note that each middleware will be given the `dispatch` and `getState` functions
 * as named arguments.
 *
 * @param {...Function} middlewares The middleware chain to be applied.
 * @returns {Function} A store enhancer applying the middleware.
 */

/*
 * This is a dummy function to check if the function name has been altered by minification.
 * If the function has been minified and NODE_ENV !== 'production', warn the user.
 */

/* 93 */

/* 94 */

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */

/* 95 */

/* 96 */

/* WEBPACK VAR INJECTION */

// Only Node.JS has a process variable that is of [[Class]] process

// For node use HTTP adapter

// For browsers use XHR adapter

/* Ignore */

/**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */

/* 97 */

// HTTP basic authentication

// Add xsrf header

// This is only done if running in a standard browser environment.

// Specifically not if we're in a web worker, or react-native.

// Set the request timeout in MS

// Listen for ready state

// The request errored out and we didn't get a response, this will be

// handled by onerror instead

// With one exception: request that using file: protocol, most browsers

// will return status as 0 even though it's a successful request

// Prepare the response

// Clean up request

// Handle browser request cancellation (as opposed to a manual cancellation)

// Handle low level network errors

// Real errors are hidden from us by the browser

// onerror should only fire if it's a network error

// Handle timeout

// Add headers to the request

// Add responseType to request if needed

// Remove Content-Type if data is undefined

// Otherwise add header to the request

// Add withCredentials to request if needed

// Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.

// But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.

// Handle progress if needed

// Not all browsers support upload events

// Handle cancellation

// Send the request

/* 98 */

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */

/* 99 */

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */

// eslint-disable-next-line no-param-reassign

/* 100 */

/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */

/* 101 */

/*!
  Copyright (c) 2017 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/

/* global define */

/* 102 */

/* 103 */

/* 104 */

/* 105 */

/* 106 */

/* 107 */

/* 108 */

/* 109 */

/* 110 */

/* 111 */

/* 112 */

/* 113 */

/* 114 */

/* 115 */

/* 116 */

/* 117 */

/* 118 */

/* 119 */

/* 120 */

/* 121 */

/* 122 */

/* 123 */

/* 124 */

/* 125 */

/* 126 */

/* 127 */

// EXTERNAL MODULE: ./node_modules/react-cookie/node_modules/cookie/index.js

// CONCATENATED MODULE: ./node_modules/react-cookie/node_modules/universal-cookie/es6/utils.js

// JSDOM does not support changing cookies, disable it for tests

// Can we get/set cookies on document.cookie?

// express prepend j: before serializing a cookie

// CONCATENATED MODULE: ./node_modules/react-cookie/node_modules/universal-cookie/es6/Cookies.js

// We can't please Rollup and TypeScript at the same time

// Only way to make both of them work

// We guess if the cookie start with { or [, it has been serialized

// At least we tried

// Ignore clean value if we failed the deserialization

// It is not relevant anymore to trim those values

/** @class */

// @ts-ignore

// Make sure to update children with new values

// CONCATENATED MODULE: ./node_modules/react-cookie/es6/useCookies.js

// CONCATENATED MODULE: ./node_modules/react-cookie/es6/index.js

/* concated harmony reexport Cookies */

/* concated harmony reexport CookiesProvider */

/* concated harmony reexport withCookies */

/* concated harmony reexport useCookies */

/* 128 */

/** @license React v16.10.2
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/* 129 */

/** @license React v16.10.2
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/

/* 130 */

/* 131 */

/** @license React v0.16.2
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/* 132 */

/* We don't import parcel.component.js from this file intentionally. See comment
   * in that file for why
   */

// React context that gives any react component the single-spa props

// required opts

// optional opts

/* 133 */

/* 134 */

// Important!

// Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.

/* 135 */

/* 136 */

/* 137 */

// @flow

/* 138 */

/**
 * Expose `pathToRegexp`.
 */

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */

// Match escaped characters that would otherwise appear in future matches.

// This allows the user to escape special characters that won't transform.

// Match Express-style parameters and un-named parameters with a prefix

// and optional suffixes. Matches appear as:

// "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]

// "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]

// "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */

// Ignore already escaped sequences.

// Push the current path onto the tokens.

// Match any characters still remaining.

// If the path exists, push it onto the end.

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */

/**
 * Expose a method for transforming tokens into the path function.
 */

// Compile all the patterns before compilation.

// Compile all the tokens into regexps.

// Prepend partial segment prefixes.

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */

/** @type {!Object} */

// Iterate over the tokens and create our regexp string.

// In non-strict mode we allow a slash at the end of match. If the path to

// match already ends with a slash, we remove it for consistency. The slash

// is valid at the end of a path match, not in the middle. This is important

// in non-ending mode, where "/test/" shouldn't match "/test//route".

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */

// Use a negative lookahead to match only capturing groups.

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */

/** @type {!Array} */

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */

/** @type {string} */

/* 139 */

/* 140 */

/** @license React v16.10.2
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/* 141 */

/* global window */

/* 142 */

// module.parent = undefined by default

/* 143 */

/* 144 */

/* 145 */

/* 146 */

/* 147 */

/* 148 */

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */

// Copy axios.prototype to instance

// Copy context to instance

// Create the default instance to be exported

// Expose Axios class to allow class inheritance

// Factory for creating new instances

// Expose Cancel & CancelToken

// Expose all/spread

// Allow use of default import syntax in TypeScript

/* 149 */

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

/* 150 */

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */

// Allow for axios('example/url'[, config]) a la fetch API

// Hook up interceptors middleware

// Provide aliases for supported request methods

/*eslint func-names:0*/

/* 151 */

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */

/* 152 */

/**
 * Throws a `Cancel` if cancellation has been requested.
 */

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */

// Support baseURL config

// Ensure headers exist

// Transform request data

// Flatten headers

// Transform response data

/* 153 */

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */

/* 154 */

/* 155 */

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */

/* 156 */

/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */

// Standard

// Microsoft

// Mozilla

// Axios

/* 157 */

// Headers whose duplicates are ignored by node

// c.f. https://nodejs.org/api/http.html#http_message_headers

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */

/* 158 */

// Standard browser envs have full support of the APIs needed to test

// whether the request URL is of the same origin as current location.

/**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */

// urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils

// IE needs attribute set twice to normalize properties

/**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */

/* 159 */

/* 160 */

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */

// A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).

// RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed

// by any combination of letters, digits, plus, period, or hyphen.

/* 161 */

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */

/* 162 */

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */

/* 163 */

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
